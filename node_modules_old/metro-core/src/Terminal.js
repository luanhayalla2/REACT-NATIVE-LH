"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = void 0;
var _lodash = _interopRequireDefault(require("lodash.throttle"));
var _readline = _interopRequireDefault(require("readline"));
var _tty = _interopRequireDefault(require("tty"));
var _util = _interopRequireDefault(require("util"));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { default: e };
}
const { promisify } = _util.default;
const moveCursor = promisify(_readline.default.moveCursor);
const clearScreenDown = promisify(_readline.default.clearScreenDown);
const streamWrite = promisify((stream, chunk, callback) => {
  return stream.write(chunk, callback);
});
function chunkString(str, size) {
  const ANSI_COLOR = "\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?m";
  const SKIP_ANSI = `(?:${ANSI_COLOR})*`;
  return str.match(new RegExp(`(?:${SKIP_ANSI}.){1,${size}}`, "g")) || [];
}
function getTTYStream(stream) {
  if (
    stream instanceof _tty.default.WriteStream &&
    stream.isTTY &&
    stream.columns >= 1
  ) {
    return stream;
  }
  return null;
}
class Terminal {
  #logLines;
  #nextStatusStr;
  #statusStr;
  #stream;
  #ttyStream;
  #updatePromise;
  #isUpdating;
  #isPendingUpdate;
  #shouldFlush;
  #writeStatusThrottled;
  constructor(stream, opts = {}) {
    this.#logLines = [];
    this.#nextStatusStr = "";
    this.#statusStr = "";
    this.#stream = stream;
    this.#ttyStream = (opts.ttyPrint ?? true) ? getTTYStream(stream) : null;
    this.#updatePromise = null;
    this.#isUpdating = false;
    this.#isPendingUpdate = false;
    this.#shouldFlush = false;
    this.#writeStatusThrottled = (0, _lodash.default)(
      (status) => this.#stream.write(status),
      3500,
    );
  }
  #scheduleUpdate() {
    if (this.#isUpdating) {
      this.#isPendingUpdate = true;
      return;
    }
    this.#isUpdating = true;
    this.#updatePromise = this.#update().then(async () => {
      while (this.#isPendingUpdate) {
        if (!this.#shouldFlush) {
          await new Promise((resolve) 